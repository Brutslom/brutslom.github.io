---
layout: post
title: METODOLOGÍA DE PENTESTING HACIA UN DIRECTORIO ACTIVO. RECONOCIMIENTO (PARTE
  5) (ES)
categories:
- español
tags:
- metodología
- pentesting
- Active Directory
img_path: "/assets/img/posts/20230113/"
date: 2023-01-13 00:00 +0000
---
Hola a todos,

Tras introducir la propuesta a desarrollar por el pentester vamos a entrar en materia presentando la siguiente etapa de la metodología el `Reconocimiento`.


# Introducción 

Tras establecer el alcance de la auditoria nos encontramos con la siguiente situación, el pentester se conecta al entorno vulnerable y la propia red le facilita una ip, gracias al protocolo DHCP.

![Estado actual](estado-1.png){: width="1232" height="554" }
_Estado actual_

# Reconocimiento

>Esta fase dependerá del tipo de auditoria establecida:
>- Caja negra: el pentester deberá obtener toda la información posible desde fuentes abiertas y accesibles, generalmente mediante técnicas [**OSINT (Open-Source Intelligence)**](https://www.sentinelone.com/cybersecurity-101/open-source-intelligence-osint/).
>- Caja gris/blanca: el pentester deberá enumerar todos los servicios disponibles en los sistemas acordados para atacarlos en las siguientes fases.


![Alcance](reconocimiento.png){: width="972" height="589" }
_Alcance_


En este punto se buscarán todos los equipos de la red vulnerable y los posibles usuarios disponibles del AD.

## Reconocimiento de equipos

Con los sistemas desplegados y el SO de pentesting activo sobre la misma red se debe realizar un reconocimiento de los equipos de la red, mediante el comando:

```bash
ifconfig
```
Se puede saber en qué segmento de la red se encuentra el SO de pentesting, en el caso de este proyecto todos los equipos están comprendidos en el rango de red 192.168.140.X con mascara de red 255.255.255.0.

El reconocimiento de los equipos del entorno puede realizarse mediante varías herramientas que realizan consultas a los protocolos que utilizan los sistemas Windows, como ARP o el protocolo SAMBA; en este proyecto se realizará mediante el protocolo SAMBA, que se explicará más adelante, a través de la herramienta [**crakcmapexec**](https://github.com/Porchetta-Industries/CrackMapExec) con el comando:

```bash
cme smb 192.168.140.0/24
```
El resultado puede comprobarse en la siguiente imagen:

![Resultado crackmapexec](cme-smb.png){: width="972" height="589" }
_Resultado crackmapexec_

Si tras la búsqueda no se encuentra ningún equipo se deberá intentar cambiar de red y volver a escanearla en búsqueda de nuevos equipos o a través de otros protocolos disponibles.

Este comando presenta todos los equipos disponibles con el protocolo SAMBA:
- Su ip.
- Su nombre en la red.
- Su sistema operativo.
- El dominio al que pertenece.
- Si firma el protocolo, con el fin de proteger la red, como se verá más adelante.
- La versión sobre la que tiene soporte el protocolo.

Como se puede comprobar se han reconocido un total de 4 equipos en la red, nos centraremos en el ataque al cliente que se emula con las máquinas de Windows 10 y al AD que se emula con la máquina de Windows Server 2016.

Por lo que el estado actual de la auditoria sería el siguiente:

![Estado tras reconocimiento de equipos](estado-2.png){: width="1232" height="554" }
_Estado tras reconocimiento de equipos_

## Reconocimiento de servicios

En el siguiente paso, para cada uno de los equipos encontrados se debe realizar un escaneo de todos los puertos que tienen abiertos con el fin de conocer los servicios que corren en estos equipos y así poder vulnerarlos. Se puede empezar por los puertos bien conocidos o escanear todo el rango de puertos que posee un equipo directamente, tanto por el protocolo UDP como por el TCP, en función de si se llega a obtener información sobre uno u otro.

Para el reconocimiento de servicios se utilizará la herramienta [**nmap**](https://nmap.org/), con el comando:

```bash
nmap -sSV -n -Pn -p- -O 192.168.140.X
```
Los diferentes parámetros presentados en la herramienta corresponden a estas finalidades:

- sSV: es una combinación de dos parámetros:
    + sS: que realiza un TCP SYN port scan, "`se envía un paquete SYN, como si se fuera a abrir una conexión real y después se espera una respuesta. Si se recibe un paquete SYN/ACK esto indica que el puerto está en escucha (abierto), mientras que si se recibe un RST (reset) indica que no hay nada escuchando en el puerto. Si no se recibe ninguna respuesta después de realizar algunas retransmisiones entonces el puerto se marca como filtrado. También se marca el puerto como filtrado si se recibe un error de tipo ICMP no alcanzable`{: .filepath}" [**Fuente**](https://nmap.org/man/es/man-port-scanning-techniques.html)
    + sV: detecta el nombre del servicio y la versión que corre.

- n: se utiliza para no realizar resolución DNS.
- Pn: sirve para no realizar descubrimientos sobre la red, ya que sabemos en que ip se encuentran los equipos.
- p-: se usa para buscar en todo el rango de puertos disponibles en la capa de transporte del modelo de red disponible, desde el 0 al 65535.
- O: se utiliza para obtener el sistema operativo del equipo escaneado, en este trabajo, se usa para confirmar que el equipo escaneado es el adecuado.

Tras lanzarlo sobre la ip: 192.168.140.129 (AD), nos facilita todos los puertos abiertos junto con los servicios que corren y sus versiones.

![Nmap AD](nmap-ad.png){: width="972" height="589" }
_Nmap AD_

Como resultado del comando los puertos abiertos en los que se deben hacer hincapié son:
- 51: que referencia a la consulta de DNS.
- 88: que alberga el servicio de Kerberos.
- 135: permite la comunicación entre procesos (RPC).
- 389 y 3268: permiten el acceso a directorios para buscar elementos de la red (LDAP).
- 139 y 445: permite la compartición de elementos sobre la red (SMB).

Tras escanear el resto de las ip que corresponden a los clientes todos presentan los mismos servicios abiertos. 

![Nmap clientes](nmap-cliente.png){: width="972" height="589" }
_Nmap clientes_

Los puertos con servicios conocidos sobre los que se debe investigar, en este tipo de equipos, son:
- 135: que permite la comunicación entre procesos (RPC).
- 139 y 445: permite la compartición de elementos sobre la red (SMB)

![Estado tras reconocimiento de servicios](estado-3.png){: width="1232" height="554" }
_Estado tras reconocimiento de servicios_

# Reconocimiento de usuarios


Por último, se debe realizar un reconocimiento de los usuarios, ya que muchos de los protocolos y servicios no facilitarán nueva información si no te autenticas o facilitas un nombre de usuario valido. Esto se obtiene mediante fuerza bruta probando los posibles usuarios que se autentican contra los servicios abiertos.

Como se puede comprobar en el reconocimiento de equipos, los nombres de los equipos pueden ser bastante descriptivos a la hora de enumerar los posibles usuarios de los mismos, se va a realizar un ataque de fuerza bruta utilizando el protocolo de kerberos, que se ha comprobado que está abierto en el puerto 88 del AD y que se explicará más adelante, junto con la herramienta nmap a la que le pasaremos un [**diccionario**](https://github.com/danielmiessler/SecLists/blob/master/Usernames/cirt-default-usernames.txt) con posibles usuarios.

El diccionario elegido se debe modificar para presentar todas las posibles opciones disponibles, entre ellas añadiremos los nombres de pc, que generalmente se pueden llegar a usar como los nombres de usuarios. Con la herramienta [**cupp**](https://github.com/Mebus/cupp), que utiliza el diccionario facilitado, genera nuevas palabras, en este caso usuarios, utilizando las siguientes preguntas:

- ¿Quieres concatenar todas las palabras de la lista?: permite permutar todas las palabras que se encuentra en el archivo.
- ¿Quieres añadir caracteres especiales al final de las palabras?: añade estos caracteres “!, @, '#’, $, %%, &, *”, al final de cada palabra.
- ¿Quieres añadir números aleatorios al final de las palabras?: añade números de 0 al 100 en todas las palabras.
- ¿Quieres sustituir letras por números?: sustituye los siguientes caracteres por número en todas las palabras a=4, i=1, e=3, t=7, o=0, s=5, g=9, z=2.

El comando para utilizar será:

```bash
cupp -w archivo.txt
```
Finalmente, tras responder todas las cuestiones se obtiene un nuevo diccionario con extensión `cupp.txt` con 12512 posibles usuarios. El resultado del comando será el siguiente:

![Cupp](cupp.png){: width="972" height="589" }
_Cupp_

Tras lanzar el comando de nmap:
```bash
nmap -p 88 --script=krb5-enum-users --script-args krb5-enum-users.realm='jcballer.local',userdb=usernames2.txt 192.168.140.129
```
Que contiene los siguientes parámetros intermedios y al final la ip objetivo:
- p: indica el puerto sobre el que atacar.
- script: escoge el script de su base de datos a utilizar.
- script-args: manda al script elegido los argumentos necesarios para su ejecución.
- krb5-enum-users.realm: argumento necesario para el script “krb5-enum-users” que indica el dominio asociado de los usuarios.
- userdb: argumento necesario para el script “krb5-enum-users” que indica diccionario a probar sobre el servicio Kerberos del AD.

El resultado del comando es el siguiente:

![Nmap enum](nmap-enum.png){: width="972" height="589" }
_Nmap enum_

Se observa cómo devuelve los usuarios correspondientes al AD (se debe separar en varios archivos porque la fuerza bruta contra el servicio hace que pierda la conexión tras varios intentos):

- jcaballero1@jcaballer.local
- administrador@jcaballer.local
- jcaballero2@jcaballer.local
- jcaballero3@jcaballer.local
- jcaballeroadm@jcaballer.local

Obteniendo el siguiente estado:

![Estado tras reconocimiento de usuarios](estado-4.png){: width="1232" height="554" }
_Estado tras reconocimiento de usuarios_

___

# Conclusión

Esto sería todo, en el siguiente post introduciremos el estudio de los servicios abiertos así como sus posibles vulnerabilidades.